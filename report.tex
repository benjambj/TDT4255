\documentclass{article}
\usepackage[colorlinks=true]{hyperref}
\title{Exercise 1 - Report}
\author{Benjamin Bj\o rnseth}
\begin{document}
\maketitle 
\begin{abstract}
In this exercise, our task was to make a small combinatorial ALU. I made one which ended up supporting a small amount of basic arithmetic and logical operations, and which sets status flags according to the calculation's results. It includes a barrel shifter, which supports both arithmetic and logical shifts left and right. Functions that were not implemented include rotating and unsigned arithmetic.
\end{abstract}

\section{Introduction}
\label{sec:introduction}
Our task was to implement a combinatorial ALU in VHDL. It was to support some basic binary calculations, although it was not specified which were needed. This meant that we had to decide upon a subset of the different plausible functions we could implement, and also determine a mapping from the binary value in our function input signal to the calculation performed. Our ALU was also to include a barrel shifter as a component, as well as an register for storing our status. What values this register could assume after an instruction was performed and what it would mean was left for us to define. The ALU would then be integerated as a peripheral in an embedded system, which was to be uploaded on an FPGA \footnote{The FPGA was from the Spartan 6 family, contained on an Avnet S6LX16 development board}. 

We were also to perform three kinds of tests to make sure our design worked:
\begin{description}
\item[Functionality Simulation] Through the use of ModelSIM, we were to assess our VHDL design's functionality. This was to be done by creating a VHDL test bench, and checking whether the output signals were what was expected.
\item[Timing Simulation] Using ModelSIM, we were also to determine any timing constraints on our modelled system.
\item[FPGA Functionality Tests] We were also to test that our code, once uploaded onto the FPGA, did what it was supposed to do on the chip. We were to do this by communicating with a C driver program, which mapped our input values onto the ALU and sent back its output signals.
\end{description}

As I had not had any prior exposure neither to VHDL nor embedded systems programming, this task was not easy to come to grips with. I had, however, some experience from the first assignment given to us, and so I used this as a starting point to try figuring out how I was supposed to go about implementing this ALU. Apart from a few `must have' instructions, namely add and subtract, the final selection of supported functions was reached through an incremental approach. Basically, a function was implemented, tested, corrected, and then a new one was written. The carry flags were decided upon with guidance from the compendium; their semantics, however, were decided upon after rather careful consideration of the supported functions' semantics. 

\section{Solution}
\label{sec:solution}
The VHDL implementation of my solution is given in the file \emph{alu.vhd}. This file contains the description of my ALU entity, which has five signals:
\begin{enumerate}
\item alu_in_a, which henceforth will be referred to as $A$.
\item alu_in_b, which henceforth will be referred to as $B$.
\item alu_in_funct, which henceforth will be referred to as $F$.
\item alu_out, which henceforth will be referred to as $O$.
\item alu_status, which henceforth will be referred to as $S$.
\end{enumerate}
Signals $A$, $B$ and $F$ are input signals, while $O$ and $S$ are output signals. $A$ and $B$ contains the function operands, $F$ is used for deciding which operation to perform, $O$ stores the result, and $S$ stores the status flag as described in \autoref{flags}.

\paragraph{Supported Operations}
\label{ops}
The functions my ALU ended up supporting are listed in \autoref{functions}. The gap between multiplication and nor results from an unimplemented division function, which was supposed to have function code $0x3$. The code values have been grouped together in logical groups for ease of remembrance, and not through some clever scheme to reduce circuit logic.

\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    {\bf Function}         & {\bf Function Code} \\ \hline
    addition               & 0x0 \\ \hline
    subtraction            & 0x1 \\ \hline
    multiplication         & 0x2 \\ \hline
    bitwise logical nor    & 0x4 \\ \hline
    bitwise logical xor    & 0x5 \\ \hline
    bitwise logical or     & 0x6 \\ \hline
    bitwise logical and    & 0x7 \\ \hline
    logical left shift     & 0x8 \\ \hline
    arithmetic left shift  & 0x9 \\ \hline
    logical right shift    & 0xA \\ \hline
    arithmetic right shift & 0xB \\ \hline
  \end{tabular}
  \caption{Supported functions. The \emph{Function Code} column describes the value of $F$ required to perform the calculation indicated in column \emph{Function}}
  \label{functions}
\end{table}

\paragraph{Status Flags}
\label{flags}
We have four flags, pos 0, 1, 2, 3:
\begin{description}
\item[Z (Zero):] Set to 1 if the ALU result is zero
\item[N (Negative):] Set to 1 if the ALU result is negative
\item[V (Overflow):] Valid for signed calculations only. Tells whether the result of the computation was too big to store in 31 bits, and whether the calculation wrapped around or not. We have three cases:
\begin{itemize}
\item For addition and subtraction, it works blalbala
\item For left arithmetic shifts it is set if the result is negative while the input was positive, or vice versa. If the calculation wraps around without changing the sign, it is deemed as not being a problem with the signed interpretation, and as such overflow is not set.
\item  For arithmetic right shift, it isn't valid.
\end{itemize}
\item[C (Carry):] Valid for unsigned calculations only. Tells whether the result generated a final bit out of its calculation
\begin{itemize}
\item Logical left shift
\item Logical right shift
\item Unsigned arithmetic..?
\end{itemize}

Multiplication issues described in \ref{subsec:limitations}
\end{description}



\subsection{The Barrel Shifter}
\label{subsubsec:barrelshifter}


\section{Result}
\label{sec:result}
I think what I ended up doing, and what tests were done should go here.
\subsection{Tests of the Implementation}
\label{sec:tests}

\subsubsection{Functionality Simulation}
\label{subsec:funcsim}

\subsubsection{Timing Simulation}
\label{subsec:timingsim}

\subsubsection{Functionality Tests on the FPGA}
\label{subsec:funcfpga}

\subsection{Design Limitations}
\label{subsec:limitations}
\paragraph{Multiplication}

\subsection{Reusability}
\label{subsec:reusability}

\section{Discussion}
\label{sec:discussion}
Discussion of what went well, and what could've been done better. Things I might have thought about, and things I could have implemented. Maybe include focus and time lost on understanding our implementation tools, which resulted in less consideration left for e.g. function value => function mapping, supported functions, status flags etc.

\section{Conclusion}
\label{sec:conclusion}
Round-up of sorts. Future work?




\end{document}
