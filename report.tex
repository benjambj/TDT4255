\documentclass{article}
\usepackage[colorlinks=true]{hyperref}
\title{Exercise 1 - Report}
\author{Benjamin Bj\o rnseth}
\begin{document}
\maketitle 
\begin{abstract}
In this exercise, our task was to make a small combinatorial ALU. I made one which ended up supporting a small amount of basic arithmetic and logical operations, and which sets status flags according to the calculation's results. It includes a barrel shifter, which supports both arithmetic and logical shifts left and right. Functions that were not implemented include rotating and unsigned arithmetic.
\end{abstract}

\section{Introduction}
\label{sec:introduction}
Our task was to implement a combinatorial ALU in VHDL. It was to support some basic binary calculations, although it was not specified which were needed. This meant that we had to decide upon a subset of the different plausible functions we could implement, and also determine a mapping from the binary value in our function input signal to the calculation performed. Our ALU was also to include a barrel shifter as a component, as well as an register for storing our status. What values this register could assume after an instruction was performed and what it would mean was left for us to define. The ALU would then be integerated as a peripheral in an embedded system, which was to be uploaded on an FPGA \footnote{The FPGA was from the Spartan 6 family, contained on an Avnet S6LX16 development board}. 

We were also to perform three kinds of tests to make sure our design worked:
\begin{description}
\item[Functionality Simulation] Through the use of ModelSIM, we were to assess our VHDL design's functionality. This was to be done by creating a VHDL test bench, and checking whether the output signals were what was expected.
\item[Timing Simulation] Using ModelSIM, we were also to determine any timing constraints on our modelled system.
\item[FPGA Functionality Tests] We were also to test that our code, once uploaded onto the FPGA, did what it was supposed to do on the chip. We were to do this by communicating with a C driver program, which mapped our input values onto the ALU and sent back its output signals.
\end{description}

As I had not had any prior exposure neither to VHDL nor embedded systems programming, this task was not easy to come to grips with. I had, however, some experience from the first assignment given to us, and so I used this as a starting point to try figuring out how I was supposed to go about implementing this ALU. Apart from a few `must have' instructions, namely add and subtract, the final selection of supported functions was reached through an incremental approach. Basically, a function was implemented, tested, corrected, and then a new one was written. The carry flags were decided upon with guidance from the compendium; their semantics, however, were decided upon after rather careful consideration of the supported functions' semantics. 

\section{Solution}
\label{sec:solution}
The VHDL implementation of my solution is given in the file \emph{alu.vhd}. This file contains the description of my ALU entity, which the following five signals.

\begin{enumerate} 
\item alu\_in\_a, which henceforth will be referred to as $A$.
\item alu\_in\_b, which henceforth will be referred to as $B$.
\item alu\_in\_funct, which henceforth will be referred to as $F$.
\item alu\_out, which henceforth will be referred to as $O$.
\item alu\_status, which henceforth will be referred to as $S$.
\end{enumerate}

Signals $A$, $B$ and $F$ are input signals, while $O$ and $S$ are output signals. $A$ and $B$ contains the function operands, $F$ is used for deciding which operation to perform, $O$ stores the result, and $S$ stores the status flag as described in \autoref{flags}.

\paragraph{Supported Operations}
\label{ops}
The functions my ALU ended up supporting are listed in \autoref{tab:functions}. The gap between multiplication and nor results from an unimplemented division function, which was supposed to have function code $0x3$. The code values have been grouped together in logical groups for ease of remembrance, and not through some clever scheme to reduce circuit logic. Most functions are commutative; the only exceptions to this are the shift operators, in which $A$ contains the operand to shift and $B$ contains the shift amount.

\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    {\bf Function}         & {\bf Function Code} \\ \hline
    addition               & 0x0 \\ \hline
    subtraction            & 0x1 \\ \hline
    multiplication         & 0x2 \\ \hline
    bitwise logical nor    & 0x4 \\ \hline
    bitwise logical xor    & 0x5 \\ \hline
    bitwise logical or     & 0x6 \\ \hline
    bitwise logical and    & 0x7 \\ \hline
    logical left shift     & 0x8 \\ \hline
    arithmetic left shift  & 0x9 \\ \hline
    logical right shift    & 0xA \\ \hline
    arithmetic right shift & 0xB \\ \hline

  \end{tabular}
  \caption{Supported functions. The \emph{Function Code} column describes the value of $F$ required to perform the calculation indicated in column \emph{Function}}
  \label{tab:functions}
\end{table}

\paragraph{Status Flags}
\label{flags}
The ALU's different status flags are listed in \autoref{tab:flags}. They have been cleverly defined as different powers of two so that they can be or'ed together to perform conjunction of statuses. Thus, I shall use the phrase `the status flag is set to \emph{\textless{}flag name\textgreater{}}' to mean `$S \& \emph{\textless{}corresponding code\textgreater{}} \neq 0$'
\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Flag name} & \textbf{Code} \\ \hline
    Zero     & 0x1 \\ \hline
    Negative & 0x2 \\ \hline
    Overflow & 0x4 \\ \hline
    Carry    & 0x8 \\ \hline
  \end{tabular}
  \caption{ALU status flags}
  \label{tab:flags}
\end{table}

their semantics are defined as follows:
\begin{itemize}
\item The `Zero' flag is set whenever $O = 0$.
\item The `Negative' flag is set when the operation just performed is of such a nature that a result should be interpreted as a signed number, and when $O < 0$. In particular, it can be set after addition, subtraction, multiplication and arithmetic shifts, but not after the logic operations.
\item The `Overflow' flag is also used for signed calculations, and is set whenever the finiteness of the result register causes $O$ to unexpectedly change sign\footnote{The exception to this is multiplication, which does not trigger overflow even though it is a signed arithmetic operation. The reason for this is that multiplication is already so severely limited in my implementation that reporting overflow would hardly matter. For more details, see \autoref{subsec:limitations}.}. Speficially, it may be set after addition, subtraction and arithmetic left shift\footnote{Arithmetic right shifts will never overflow, as they use sign extension; see \autoref{subsec:barrelshifter}}. For addition, overflow is set~$\iff~sign(A)=sign(B)\wedge{}sign(A)\neq{}sign(O)$. As subtraction is addition of a negative number, the previous equation holds with $sign(A)=sign(B)$ replaced with $sign(A)\neq{}sign(B)$. For arithmetic left shifts, the overflow flag is set if $O$ has a different sign from $A$. If the calculation does not change the sign, shifting bits out of $A$ is deemed as not being a problem with the signed interpretation, and as such overflow is not set.
\item The `Carry' flag is used for extending the result register on unsigned calculations. For my chosen set of instructions, this is only necessary for logical left/right shifts. In these cases, the carry bit is set to the last bit shifted out.
\end{itemize}

\subsection{The Barrel Shifter}
\label{subsec:barrelshifter}


\section{Result}
\label{sec:result}
I think what I ended up doing, and what tests were done should go here.
\subsection{Tests of the Implementation}
\label{sec:tests}

\subsubsection{Functionality Simulation}
\label{subsec:funcsim}

\subsubsection{Timing Simulation}
\label{subsec:timingsim}

\subsubsection{Functionality Tests on the FPGA}
\label{subsec:funcfpga}

\subsection{Design Limitations}
\label{subsec:limitations}
\paragraph{Multiplication}

\subsection{Reusability}
\label{subsec:reusability}

\section{Discussion}
\label{sec:discussion}
Discussion of what went well, and what could've been done better. Things I might have thought about, and things I could have implemented. Maybe include focus and time lost on understanding our implementation tools, which resulted in less consideration left for e.g. function value => function mapping, supported functions, status flags etc.

\section{Conclusion}
\label{sec:conclusion}
Round-up of sorts. Future work?




\end{document}
